---
layout: post
title:  "Git Internal - 读取 Git 中的 pack 文件"
date:   2015-10-01 14:07:00
categories: git_internal
---

在我之前的 Git Internal 系列的第一篇[《Git Internal - Git 中的 Object 和 Reference》](/git_internal/2015/10/01/git-internal-objects-and-refs.html)中，我简单介绍了 Git 如何用 object 文件存储 Git 的所有 object，但事实上，这种方法不够高效，它存在三个性能问题：

1. 大规模读取提交日志时，需要反复读取多个文件才能获取全部信息
2. 对于大量小修小改的情况，blob 或 tree 之间改动不大，但每次都要存储整个 blob 和 tree，从执行性能和存储空间来说都不够高效
3. 大量小文件降低了对存储空间的有效利用

因此 Git 后来改进了存储方式，通过 `git gc` 命令可以将多个 object 文件打包成 pack 存储，并增加了两种 DIFF object 来提高读写小规模改动的性能。

在这篇 Blog 中，我将给出读取 pack 文件的方法。

在 Git 文件中，pack 文件存储在 .git/objects/pack/ 目录中，全部以 `pack-` 开头。每个 pack 由两个文件构成，一个索引文件 .idx，用于 object 的定位，一个 .pack 文件存储 object 的内容。

先从索引文件 .idx 开始讲，Git 的索引文件有两个版本，版本 1 比较简单，文件内容共分四个部分：

1. 扇出表，共 256 项，每项有 4 个字节的网络序数字构成，用于定位 SHA-1 在索引表中的位置
2. 索引表，存储所有索引项，每项 24 个字节，前 20 个字节是 object 的 SHA-1，后面 4 个字节是 object 在 .pack 文件中的偏移量（由此可以看出，版本 1 的 .pack 文件不能大于 4 GB，否则无法存储偏移量），网络序存储，所有索引项按照 SHA-1 排序
3. .pack 文件内容的 SHA-1，20 个字节
4. 上述所有文件内容的 SHA-1，20 个字节

版本 2 改进了版本 1 中的几个问题，是目前 Git 广泛采用的版本，现在文件内容共分 9 个部分：

1. 文件签名 `\377tOc`，4 个字节
2. 索引文件版本，4 个字节
3. 扇出表，和版本 1 一致
4. 索引表，每项 20 个字节，存储所有索引的 SHA-1 部分，按 SHA-1 排序
5. CRC32 表，每项 4 个字节，顺序与其对应的 SHA-1 顺序一致
6. 偏移量表，每项 4 个字节，与版本 1 的偏移量不同，版本 2 中的偏移量当最高位为 0 时，低 31 位表示 object 在 .pack 文件中的偏移量，总共能表示 2 GB。当最高位为 1 时，低 31 位表示实际偏移量在扩展偏移量表的位置。
7. 扩展偏移量表，每项 8 个字节，当偏移量大于 2 GB 时，就会改用扩展偏移量表存储，扩展偏移量可以用 8 个字节表示。
8. .pack 文件内容的 SHA-1，20 个字节
9. 上述所有文件内容的 SHA-1，20 个字节

以在 pack 文件中搜索 7105cee64d76781823dbc68f4e154e51e47c3585 为例，其 SHA-1 的第一个字节用数字表示是 113(计算方法是 7 * 16 + 1)，因此取出扇出表第 113 项数据，其值是 41834，还要取出扇出表第 112 项数据（即前一项数据），其值是 41502，这表示 7105cee64d76781823dbc68f4e154e51e47c3585 这个数据的索引项一定位于索引表第 41502 ～ 41834 项中，由于索引表按照 SHA-1 排序，因此可以用二分法找到它在索引表中的位置，例如是 41517。

对于版本 1 的索引文件，直接取出 SHA-1 部分后面 4 个字节就得到了它在 .pack 文件中的位置。如果是版本 2，则需要再取出偏移量表的第 41517 项，还需要判断该偏移量的最高位是否是 0。假设这里的偏移量大于 2 GB，因此最高位是 1，例如是 0x80000005，则需要再次从扩展偏移量表中取出第 5 项，才能得到实际的偏移量。


